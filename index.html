<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹¤ì œ ë©€í‹°í”Œë ˆì´ì–´ 2D ìŠˆíŒ… ê²Œì„</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
        }
        
        #connectionPanel {
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            color: #fff;
            text-align: center;
            margin-bottom: 20px;
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #333;
            display: none;
        }
        
        #gameCanvas {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            z-index: 10;
        }
        
        #leaderboard {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            color: #fff;
            min-width: 150px;
            z-index: 10;
        }
        
        #playerInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            z-index: 10;
        }
        
        #connectionStatus {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #fff;
            font-size: 12px;
            z-index: 10;
        }
        
        .health-bar, .ammo-bar {
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin: 2px 0;
        }
        
        .health-bar { width: 100px; }
        .ammo-bar { width: 80px; }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #f00, #ff0, #0f0);
            transition: width 0.3s ease;
        }
        
        .ammo-fill {
            height: 100%;
            background: #00f;
            transition: width 0.3s ease;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            background: #4ecdc4;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #45b7d1;
        }
        
        input {
            padding: 8px;
            font-size: 14px;
            border: 1px solid #333;
            border-radius: 5px;
            margin: 5px;
        }
        
        .room-code {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            background: #333;
            padding: 10px;
            border-radius: 5px;
            display: inline-block;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="connectionPanel">
        <h2>ğŸ® ë©€í‹°í”Œë ˆì´ì–´ ìŠˆíŒ… ê²Œì„</h2>
        <div id="joinOptions">
            <div>
                <input type="text" id="playerNameInput" placeholder="í”Œë ˆì´ì–´ ì´ë¦„" value="" maxlength="10">
            </div>
            <div>
                <button onclick="createRoom()">ğŸ†• ë°© ë§Œë“¤ê¸°</button>
                <button onclick="showJoinRoom()">ğŸšª ë°© ì°¸ê°€í•˜ê¸°</button>
            </div>
            <div id="joinRoomPanel" style="display: none;">
                <input type="text" id="roomCodeInput" placeholder="ë°© ì½”ë“œ ì…ë ¥" maxlength="6">
                <button onclick="joinRoom()">ì°¸ê°€</button>
            </div>
        </div>
        
        <div id="roomInfo" style="display: none;">
            <h3>ë°©ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!</h3>
            <p>ë‹¤ë¥¸ í”Œë ˆì´ì–´ê°€ ì ‘ì†í•  ìˆ˜ ìˆë„ë¡ ì•„ë˜ ì½”ë“œë¥¼ ê³µìœ í•˜ì„¸ìš”:</p>
            <div class="room-code" id="roomCodeDisplay"></div>
            <p>ì—°ê²°ëœ í”Œë ˆì´ì–´: <span id="connectedPlayers">1</span>/4</p>
            <button onclick="startGame()" id="startGameBtn">ê²Œì„ ì‹œì‘</button>
        </div>
        
        <div id="waitingRoom" style="display: none;">
            <h3>ë°©ì— ì°¸ê°€í–ˆìŠµë‹ˆë‹¤!</h3>
            <p>ë°©ì¥ì´ ê²Œì„ì„ ì‹œì‘í•˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</p>
            <p>ì—°ê²°ëœ í”Œë ˆì´ì–´: <span id="waitingPlayers">1</span>/4</p>
        </div>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="ui">
            <div>ì²´ë ¥: <div class="health-bar"><div class="health-fill" id="healthBar" style="width: 100%"></div></div></div>
            <div>íƒ„ì•½: <div class="ammo-bar"><div class="ammo-fill" id="ammoBar" style="width: 100%"></div></div></div>
            <div>ì ìˆ˜: <span id="score">0</span></div>
        </div>
        
        <div id="leaderboard">
            <h3>ğŸ† ë¦¬ë”ë³´ë“œ</h3>
            <div id="leaderboardList"></div>
        </div>
        
        <div id="playerInfo">
            <div>í”Œë ˆì´ì–´: <span id="currentPlayer"></span></div>
            <div>ë°© ì½”ë“œ: <span id="gameRoomCode"></span></div>
        </div>
        
        <div id="connectionStatus">
            <div>ì—°ê²°ëœ í”Œë ˆì´ì–´: <span id="gameConnectedPlayers">1</span></div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let isHost = false;
        let playerName = '';
        let roomCode = '';
        let connections = new Map();
        let gameStarted = false;
        
        // ê²Œì„ ìƒíƒœ
        const gameState = {
            players: new Map(),
            bullets: [],
            ammoPickups: [],
            healthPickups: []
        };
        
        // WebRTC ì„¤ì •
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
        
        // ë°© ì½”ë“œ ìƒì„±
        function generateRoomCode() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }
        
        // í”Œë ˆì´ì–´ í´ë˜ìŠ¤
        class Player {
            constructor(id, name, x, y, color) {
                this.id = id;
                this.name = name;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.color = color;
                this.health = 100;
                this.maxHealth = 100;
                this.ammo = 30;
                this.maxAmmo = 30;
                this.score = 0;
                this.radius = 15;
                this.speed = 3;
                this.lastShot = 0;
                this.shootCooldown = 200;
                this.ammoRegenTime = 0;
                this.ammoRegenRate = 2000;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                this.x = Math.max(this.radius, Math.min(800 - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(600 - this.radius, this.y));
                
                this.vx *= 0.9;
                this.vy *= 0.9;
                
                const now = Date.now();
                if (now - this.ammoRegenTime > this.ammoRegenRate && this.ammo < this.maxAmmo) {
                    this.ammo++;
                    this.ammoRegenTime = now;
                }
            }
            
            shoot(targetX, targetY) {
                const now = Date.now();
                if (now - this.lastShot < this.shootCooldown || this.ammo <= 0) {
                    return null;
                }
                
                const angle = Math.atan2(targetY - this.y, targetX - this.x);
                const bullet = new Bullet(this.x, this.y, angle, this.id);
                
                this.ammo--;
                this.lastShot = now;
                return bullet;
            }
            
            takeDamage(damage) {
                this.health = Math.max(0, this.health - damage);
                if (this.health <= 0) {
                    this.respawn();
                    return true;
                }
                return false;
            }
            
            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
            }
            
            respawn() {
                this.x = Math.random() * (800 - 60) + 30;
                this.y = Math.random() * (600 - 60) + 30;
                this.health = this.maxHealth;
                this.ammo = this.maxAmmo;
                this.score = Math.max(0, this.score - 10);
            }
            
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                const barWidth = 30;
                const barHeight = 4;
                const barY = this.y - this.radius - 10;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
                
                ctx.fillStyle = this.health > 60 ? '#0f0' : this.health > 30 ? '#ff0' : '#f00';
                ctx.fillRect(this.x - barWidth/2, barY, (this.health / this.maxHealth) * barWidth, barHeight);
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x, this.y - this.radius - 15);
            }
            
            serialize() {
                return {
                    id: this.id,
                    name: this.name,
                    x: this.x,
                    y: this.y,
                    vx: this.vx,
                    vy: this.vy,
                    health: this.health,
                    ammo: this.ammo,
                    score: this.score,
                    color: this.color
                };
            }
        }
        
        // ì´ì•Œ í´ë˜ìŠ¤
        class Bullet {
            constructor(x, y, angle, ownerId) {
                this.id = 'bullet_' + Math.random().toString(36).substr(2, 9);
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * 8;
                this.vy = Math.sin(angle) * 8;
                this.ownerId = ownerId;
                this.radius = 3;
                this.damage = 15;
                this.life = 100;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                
                return this.x > 0 && this.x < 800 && 
                       this.y > 0 && this.y < 600 && 
                       this.life > 0;
            }
            
            draw(ctx) {
                ctx.fillStyle = '#ff0';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#ffa500';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x - this.vx * 2, this.y - this.vy * 2);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
            }
            
            serialize() {
                return {
                    id: this.id,
                    x: this.x,
                    y: this.y,
                    vx: this.vx,
                    vy: this.vy,
                    ownerId: this.ownerId,
                    life: this.life
                };
            }
        }
        
        // ì•„ì´í…œ í´ë˜ìŠ¤
        class Pickup {
            constructor(x, y, type) {
                this.id = 'pickup_' + Math.random().toString(36).substr(2, 9);
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = 8;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.1;
            }
            
            draw(ctx) {
                const pulseSize = Math.sin(this.pulse) * 2;
                
                if (this.type === 'ammo') {
                    ctx.fillStyle = '#00f';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('A', this.x, this.y + 4);
                } else if (this.type === 'health') {
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('+', this.x, this.y + 4);
                }
            }
            
            serialize() {
                return {
                    id: this.id,
                    x: this.x,
                    y: this.y,
                    type: this.type,
                    pulse: this.pulse
                };
            }
        }
        
        // ë„¤íŠ¸ì›Œí‚¹ í•¨ìˆ˜ë“¤
        function sendToAll(data) {
            const message = JSON.stringify(data);
            connections.forEach(connection => {
                if (connection.readyState === 'open') {
                    connection.send(message);
                }
            });
        }
        
        function sendToPeer(peerId, data) {
            const connection = connections.get(peerId);
            if (connection && connection.readyState === 'open') {
                connection.send(JSON.stringify(data));
            }
        }
        
        // UI í•¨ìˆ˜ë“¤
        function showJoinRoom() {
            document.getElementById('joinRoomPanel').style.display = 'block';
        }
        
        function createRoom() {
            playerName = document.getElementById('playerNameInput').value || 'í”Œë ˆì´ì–´1';
            roomCode = generateRoomCode();
            isHost = true;
            
            document.getElementById('joinOptions').style.display = 'none';
            document.getElementById('roomInfo').style.display = 'block';
            document.getElementById('roomCodeDisplay').textContent = roomCode;
            
            // ìì‹ ì„ í”Œë ˆì´ì–´ë¡œ ì¶”ê°€
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
            const currentPlayer = new Player(
                'host',
                playerName,
                Math.random() * (800 - 60) + 30,
                Math.random() * (600 - 60) + 30,
                colors[0]
            );
            gameState.players.set('host', currentPlayer);
            
            // í”¼ì–´ ì—°ê²° ëŒ€ê¸°
            setupPeerConnections();
        }
        
        function joinRoom() {
            playerName = document.getElementById('playerNameInput').value || 'í”Œë ˆì´ì–´2';
            roomCode = document.getElementById('roomCodeInput').value.toUpperCase();
            
            if (roomCode.length !== 6) {
                alert('ì˜¬ë°”ë¥¸ ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (6ìë¦¬)');
                return;
            }
            
            document.getElementById('joinOptions').style.display = 'none';
            document.getElementById('waitingRoom').style.display = 'block';
            
            // í˜¸ìŠ¤íŠ¸ì— ì—°ê²°
            connectToHost();
        }
        
        function startGame() {
            if (gameState.players.size < 2) {
                alert('ìµœì†Œ 2ëª…ì˜ í”Œë ˆì´ì–´ê°€ í•„ìš”í•©ë‹ˆë‹¤!');
                return;
            }
            
            document.getElementById('connectionPanel').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            gameStarted = true;
            
            document.getElementById('currentPlayer').textContent = playerName;
            document.getElementById('gameRoomCode').textContent = roomCode;
            document.getElementById('gameConnectedPlayers').textContent = gameState.players.size;
            
            // ëª¨ë“  ì—°ê²°ëœ í”Œë ˆì´ì–´ì—ê²Œ ê²Œì„ ì‹œì‘ ì•Œë¦¼
            sendToAll({
                type: 'gameStart',
                gameState: serializeGameState()
            });
            
            // ê²Œì„ ë£¨í”„ ì‹œì‘
            gameLoop();
        }
        
        // WebRTC ì—°ê²° ì„¤ì •
        async function setupPeerConnections() {
            // ê°„ë‹¨í•œ ì‹œê·¸ë„ë§ì„ ìœ„í•´ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì±„ë„ ì‚¬ìš© (ê°™ì€ ê¸°ê¸°ì—ì„œë§Œ ì‘ë™)
            // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ì‹œê·¸ë„ë§ ì„œë²„ê°€ í•„ìš”í•©ë‹ˆë‹¤
            
            window.addEventListener('beforeunload', () => {
                sendToAll({type: 'disconnect', playerId: 'host'});
            });
        }
        
        async function connectToHost() {
            // ì‹¤ì œ WebRTC êµ¬í˜„ì€ ë³µì¡í•˜ë¯€ë¡œ, 
            // ì—¬ê¸°ì„œëŠ” localStorageë¥¼ í†µí•œ ë¡œì»¬ ì‹œë®¬ë ˆì´ì…˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤
            
            // ì‹¤ì œ êµ¬í˜„ì‹œì—ëŠ” Socket.IOë‚˜ WebSocket ì„œë²„ê°€ í•„ìš”í•©ë‹ˆë‹¤
            alert('ì‹¤ì œ ë©€í‹°í”Œë ˆì´ì–´ëŠ” ì„œë²„ êµ¬í˜„ì´ í•„ìš”í•©ë‹ˆë‹¤.\ní˜„ì¬ëŠ” ë¡œì»¬ í…ŒìŠ¤íŠ¸ìš©ì…ë‹ˆë‹¤.');
            
            // ë¡œì»¬ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ìë™ìœ¼ë¡œ ê²Œì„ ì‹œì‘
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
            const currentPlayer = new Player(
                'guest',
                playerName,
                Math.random() * (800 - 60) + 30,
                Math.random() * (600 - 60) + 30,
                colors[1]
            );
            gameState.players.set('guest', currentPlayer);
            
            document.getElementById('connectionPanel').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            gameStarted = true;
            
            document.getElementById('currentPlayer').textContent = playerName;
            document.getElementById('gameRoomCode').textContent = roomCode;
            document.getElementById('gameConnectedPlayers').textContent = gameState.players.size;
            
            gameLoop();
        }
        
        // ê²Œì„ ìƒíƒœ ì§ë ¬í™”
        function serializeGameState() {
            return {
                players: Array.from(gameState.players.values()).map(p => p.serialize()),
                bullets: gameState.bullets.map(b => b.serialize()),
                ammoPickups: gameState.ammoPickups.map(p => p.serialize()),
                healthPickups: gameState.healthPickups.map(p => p.serialize())
            };
        }
        
        // ì¶©ëŒ ê²€ì‚¬
        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < obj1.radius + obj2.radius;
        }
        
        // í‚¤ë³´ë“œ ì…ë ¥
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // ë§ˆìš°ìŠ¤ ì…ë ¥
        document.addEventListener('click', (e) => {
            if (!gameStarted) return;
            
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const myPlayer = Array.from(gameState.players.values()).find(p => p.name === playerName);
            if (myPlayer) {
                const bullet = myPlayer.shoot(mouseX, mouseY);
                if (bullet) {
                    gameState.bullets.push(bullet);
                    
                    // ë‹¤ë¥¸ í”Œë ˆì´ì–´ë“¤ì—ê²Œ ì´ì•Œ ìƒì„± ì•Œë¦¼
                    sendToAll({
                        type: 'bulletFired',
                        bullet: bullet.serialize()
                    });
                }
            }
        });
        
        // ì•„ì´í…œ ìƒì„±
        function spawnPickups() {
            if (Math.random() < 0.005) {
                const pickup = new Pickup(
                    Math.random() * (800 - 40) + 20,
                    Math.random() * (600 - 40) + 20,
                    'ammo'
                );
                gameState.ammoPickups.push(pickup);
                
                sendToAll({
                    type: 'pickupSpawned',
                    pickup: pickup.serialize()
                });
            }
            
            if (Math.random() < 0.003) {
                const pickup = new Pickup(
                    Math.random() * (800 - 40) + 20,
                    Math.random() * (600 - 40) + 20,
                    'health'
                );
                gameState.healthPickups.push(pickup);
                
                sendToAll({
                    type: 'pickupSpawned',
                    pickup: pickup.serialize()
                });
            }
        }
        
        // ë¦¬ë”ë³´ë“œ ì—…ë°ì´íŠ¸
        function updateLeaderboard() {
            const players = Array.from(gameState.players.values())
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);
            
            const leaderboardHtml = players.map((player, index) => {
                const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : 'ğŸ…';
                return `<div>${medal} ${player.name}: ${player.score}</div>`;
            }).join('');
            
            document.getElementById('leaderboardList').innerHTML = leaderboardHtml;
        }
        
        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            if (!gameStarted) return;
            
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // ë°°ê²½ í´ë¦¬ì–´
            ctx.fillStyle = 'rgba(26, 26, 46, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // í˜„ì¬ í”Œë ˆì´ì–´ ì°¾ê¸°
            const myPlayer = Array.from(gameState.players.values()).find(p => p.name === playerName);
            
            // í”Œë ˆì´ì–´ ì…ë ¥ ì²˜ë¦¬
            if (myPlayer) {
                if (keys['KeyW'] || keys['ArrowUp']) myPlayer.vy -= 0.5;
                if (keys['KeyS'] || keys['ArrowDown']) myPlayer.vy += 0.5;
                if (keys['KeyA'] || keys['ArrowLeft']) myPlayer.vx -= 0.5;
                if (keys['KeyD'] || keys['ArrowRight']) myPlayer.vx += 0.5;
                
                // í”Œë ˆì´ì–´ ìƒíƒœë¥¼ ë‹¤ë¥¸ í”Œë ˆì´ì–´ë“¤ì—ê²Œ ì „ì†¡
                sendToAll({
                    type: 'playerUpdate',
                    player: myPlayer.serialize()
                });
            }
            
            // í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            for (const [id, player] of gameState.players) {
                player.update();
                player.draw(ctx);
            }
            
            // ì´ì•Œ ì—…ë°ì´íŠ¸
            gameState.bullets = gameState.bullets.filter(bullet => {
                const alive = bullet.update();
                if (alive) {
                    bullet.draw(ctx);
                    
                    // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ ê²€ì‚¬
                    for (const [id, player] of gameState.players) {
                        if (id !== bullet.ownerId && checkCollision(bullet, player)) {
                            const killed = player.takeDamage(bullet.damage);
                            const shooter = gameState.players.get(bullet.ownerId);
                            if (shooter) {
                                shooter.score += killed ? 20 : 10;
                            }
                            
                            // ì¶©ëŒ ì •ë³´ ì „ì†¡
                            sendToAll({
                                type: 'bulletHit',
                                targetId: id,
                                shooterId: bullet.ownerId,
                                damage: bullet.damage
                            });
                            
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            });
            
            // ì•„ì´í…œ ì—…ë°ì´íŠ¸
            gameState.ammoPickups = gameState.ammoPickups.filter(pickup => {
                pickup.update();
                pickup.draw(ctx);
                
                for (const [id, player] of gameState.players) {
                    if (checkCollision(pickup, player)) {
                        player.ammo = Math.min(player.maxAmmo, player.ammo + 10);
                        
                        sendToAll({
                            type: 'pickupCollected',
                            pickupId: pickup.id,
                            playerId: id,
                            pickupType: 'ammo'
                        });
                        
                        return false;
                    }
                }
                return true;
            });
            
            gameState.healthPickups = gameState.healthPickups.filter(pickup => {
                pickup.update();
                pickup.draw(ctx);
                
                for (const [id, player] of gameState.players) {
                    if (checkCollision(pickup, player)) {
                        player.heal(30);
                        
                        sendToAll({
                            type: 'pickupCollected',
                            pickupId: pickup.id,
                            playerId: id,
                            pickupType: 'health'
                        });
                        
                        return false;
                    }
                }
                return true;
            });
            
            // í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš°ì—ë§Œ ì•„ì´í…œ ìƒì„±
            if (isHost) {
                spawnPickups();
            }
            
            // UI ì—…ë°ì´íŠ¸
            if (myPlayer) {
                document.getElementById('healthBar').style.width = (myPlayer.health / myPlayer.maxHealth * 100) + '%';
                document.getElementById('ammoBar').style.width = (myPlayer.ammo / myPlayer.maxAmmo * 100) + '%';
                document.getElementById('score').textContent = myPlayer.score;
            }
            
            updateLeaderboard();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ì´ˆê¸° í”Œë ˆì´ì–´ ì´ë¦„ ì„¤ì •
        document.getElementById('playerNameInput').value = 'í”Œë ˆì´ì–´' + Math.floor(Math.random() * 1000);
        
        // ê²Œì„ ì„¤ëª…
        setTimeout(() => {
            if (!gameStarted) {
                alert('ì‹¤ì œ ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„!\n\nğŸ“ ë°©ë²•:\n1. í”Œë ˆì´ì–´ ì´ë¦„ ì…ë ¥\n2. ë°© ë§Œë“¤ê¸° ë˜ëŠ” ë°© ì°¸ê°€í•˜ê¸°\n3. ì¹œêµ¬ë“¤ê³¼ ì½”ë“œ ê³µìœ \n4. ê²Œì„ ì‹œì‘!\n\nğŸ® ì¡°ì‘:\nâ€¢ WASD/ë°©í–¥í‚¤: ì´ë™\nâ€¢ ë§ˆìš°ìŠ¤ í´ë¦­: ë°œì‚¬\nâ€¢ íŒŒë€ìƒ‰: íƒ„ì•½, ë¹¨ê°„ìƒ‰: ííŒ©');
            }
        }, 1000);
    </script>
</body>
</html>
